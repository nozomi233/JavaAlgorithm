# 开篇词

## 学习算法和刷题的思路指南

### 数据结构的存储⽅式

**数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储）。**  

「图」的两种表⽰⽅法，邻接表就是链表，邻接矩阵就是⼆维数组。邻接矩 阵判断连通性迅速，并可以进⾏矩阵运算解决⼀些问题，但是如果图⽐较稀 疏的话很耗费空间。邻接表⽐较节省空间，但是很多操作的效率上肯定⽐不 过邻接矩阵。   

「散列表」就是通过散列函数把键映射到⼀个⼤数组⾥。⽽且对于解决散列 冲突的⽅法，拉链法需要链表特性，操作简单，但需要额外的空间存储指 针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间， 但操作稍微复杂些。   

「树」，⽤数组实现就是「堆」，因为「堆」是⼀个完全⼆叉树，⽤数组存 储不需要节点指针，操作也⽐较简单；⽤链表实现就是很常⻅的那种 「树」，因为不⼀定是完全⼆叉树，所以不适合⽤数组存储。为此，在这种 链表「树」结构之上，⼜衍⽣出各种巧妙的设计，⽐如⼆叉搜索树、AVL 树、红⿊树、区间树、B 树等等，以应对不同的问题。

### 数据结构的基本操作

基本操作⽆⾮遍历 + 访问，再具体⼀点就是：增删查改。各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。  

**线性就是 for/while 迭代为代表，⾮线性就是递归为代表。**

## 动态规划

计算机解决问题其实没有任何奇技淫巧，它唯⼀的解决办法就是穷举，穷举所有可能性。算法设计⽆⾮就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。 

### 动态规划的一般思路流程：

**递归方法--(从上至下，增加备忘录记录子问题解)-->备忘录方法--(找到初始值，从下至上记录解)-->DP**

## 回溯算法

**解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。**

你只需要思考3个问题： 
* 路径：也就是已经做出的选择。 
* 选择列表：也就是你当前可以做的选择。 
* 结束条件：也就是到达决策树底层，⽆法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后⾯会⽤「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

**回溯算法框架中，要注意，核⼼就是 for 循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤ 之后「撤销选择」**

### 总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置 做⼀些操作，算法框架如下：
```java
void backtrack(List<Integer> path, List<Integer> choices){
    // if 满足结束条件 ,假设做10次选择后结束
    if (path.size() == 10){
        pathList.add(path);
        return;
    }

    // for 选择 in 选择列表
    for (Integer choice : choices){
        // 做选择
        path.add(choice);
        backtrack(path, choices);
        // 撤销选择
        path.remove(path.size() - 1);
    }
}
```

**写 backtrack 函数时，需要维护⾛过的「路径」和当前可以做的「选择列 表」，当触发「结束条件」时，将「路径」记⼊结果集。**

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列⽂章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和 「base case」，是不是就对应着⾛过的「路径」，当前的「选择列表」和 「结束条件」？

某种程度上说，**动态规划的暴⼒求解阶段就是回溯算法**。只是有的问题具有重叠⼦问题性质，可以⽤ dp table 或者备忘录优化，将递归树⼤幅剪枝，这就变成了动态规划。⽽今天的两个问题，都**没有重叠⼦问题**，也就是回溯算法问题了，复杂度⾮常⾼是不可避免的。

## BFS 算法框架套路详解

**DFS算法就是回溯算法～**

BFS相对DFS的最主要的区别是：**BFS找到的路径⼀定是最短的，但代价就是空间复杂度⽐DFS⼤很多**

### 算法框架

**问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离，BFS 算法问题其实都是在⼲这个事⼉。**

```java
int bfs(Node start, Node target) {
    // 核⼼数据结构
    Queue<Node> q = new LinkedList<>();
    // 避免⾛回头路
    Set<Node> visited = new HashSet<>();

    q.offer(start);
    visited.add(start);
    int step = 0;

    while (!q.isEmpty()) {
        int len = q.size();
        // 将当前队列节点向四周扩散
        for (int i = 0; i < len; i++) {
            Node cur = q.poll();
            /* 划重点：这⾥判断是否到达终点 */
            if (cur == target) {
                return step;
            }
            /* 将 cur 的相邻节点加⼊队列 */
            for (Node next : cur.nexts) {
                /**
                 * 队列 q 就不说了，BFS 的核⼼数据结构； cur.nexts 泛指 cur 相邻的节点;
                 * visited 的主要作⽤是防⽌⾛回头路，⼤部分时候都是必须的，但是像⼀般的⼆叉树结构，
                 * 没有⼦节点到⽗节点的指针，不会⾛回头路就不需要 visited 。
                 */
                if (!visited.contains(next)) {
                    q.offer(next);
                    visited.add(next);
                }
            }
        }
        /* 划重点：更新步数在这⾥ */
        step++;
    }
    return step;
}
```

eg:

[二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

[解开密码锁的最少次数](https://leetcode.cn/problems/open-the-lock/) : **这个题还是需要仔细品味下的，如果没见过很难想到**

#### 1、为什么 BFS 可以找到最短距离，DFS 不⾏吗？
BFS 的逻辑， depth 每增加⼀次，队列中的所有节点都向前迈⼀步，这保证了第⼀次到达终点的时候，⾛的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对⾼很多。 DFS实际上是靠递归的堆栈记录⾛过的路径，要找到最短路径，肯定得把⼆叉树中所有树杈都探索完才能对⽐出最短的路径有多⻓，⽽ BFS 借助队列做到⼀次⼀步「⻬头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

#### 2、既然 BFS 那么好，为啥 DFS 还要存在？
BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。 
拿求二叉树的最小深度的例⼦，假设这个⼆叉树是满⼆叉树，节点数为 N ，对于 DFS 算法来说，空间复杂度⽆⾮就是递归堆栈，最坏情况下顶多就是树的⾼度，也就是 O(logN) 。
BFS算法，队列中每次都会储存着⼆叉树⼀层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2 ，⽤ Big O 表⽰的话也就是 O(N) 。

由此观之，BFS 还是有代价的，**⼀般来说在找最短路径的时候使⽤BFS， 其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）。**

### 双向 BFS 优化

BFS 算法还有⼀种稍微⾼级⼀点的优化思路：双向BFS，可以进⼀步提⾼算法的效率。**传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停⽌；⽽双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停⽌。** 时间复杂度未变，优化了常数时间。

## 二分查找详解

⼆分查找并不简单，Knuth ⼤佬（发明 KMP 算法的那位）都说⼆分查找：**思路很简单，细节是魔⿁**。

很多⼈喜欢拿整型溢出的 bug 说事⼉，但是⼆分查找真正的坑根本就不是那个细节问题，⽽是在于**到底要给 mid 加⼀还是 减⼀，while ⾥到底⽤ <= 还是 <**。

![二分查找](binarySearch.png "二分查找labuladong口诀")

本⽂就来探究⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。

### ⼆分查找框架

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

**分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。**

### 寻找⼀个数（基本的⼆分搜索）

### 寻找左侧边界的⼆分搜索

### 寻找右侧边界的⼆分查找








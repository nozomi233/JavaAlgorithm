# 开篇词

## 学习算法和刷题的思路指南

### 数据结构的存储⽅式

**数据结构的存储⽅式只有两种：数组（顺序存储）和链表（链式存储）。**  

「图」的两种表⽰⽅法，邻接表就是链表，邻接矩阵就是⼆维数组。邻接矩 阵判断连通性迅速，并可以进⾏矩阵运算解决⼀些问题，但是如果图⽐较稀 疏的话很耗费空间。邻接表⽐较节省空间，但是很多操作的效率上肯定⽐不 过邻接矩阵。   

「散列表」就是通过散列函数把键映射到⼀个⼤数组⾥。⽽且对于解决散列 冲突的⽅法，拉链法需要链表特性，操作简单，但需要额外的空间存储指 针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间， 但操作稍微复杂些。   

「树」，⽤数组实现就是「堆」，因为「堆」是⼀个完全⼆叉树，⽤数组存 储不需要节点指针，操作也⽐较简单；⽤链表实现就是很常⻅的那种 「树」，因为不⼀定是完全⼆叉树，所以不适合⽤数组存储。为此，在这种 链表「树」结构之上，⼜衍⽣出各种巧妙的设计，⽐如⼆叉搜索树、AVL 树、红⿊树、区间树、B 树等等，以应对不同的问题。

### 数据结构的基本操作

基本操作⽆⾮遍历 + 访问，再具体⼀点就是：增删查改。各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。  

**线性就是 for/while 迭代为代表，⾮线性就是递归为代表。**

## 动态规划

计算机解决问题其实没有任何奇技淫巧，它唯⼀的解决办法就是穷举，穷举所有可能性。算法设计⽆⾮就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。 

### 动态规划的一般思路流程：

**递归方法--(从上至下，增加备忘录记录子问题解)-->备忘录方法--(找到初始值，从下至上记录解)-->DP**

**明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。**

## 回溯算法

**解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。**

你只需要思考3个问题： 
* 路径：也就是已经做出的选择。 
* 选择列表：也就是你当前可以做的选择。 
* 结束条件：也就是到达决策树底层，⽆法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后⾯会⽤「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

**回溯算法框架中，要注意，核⼼就是 for 循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤ 之后「撤销选择」**

### 总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置 做⼀些操作，算法框架如下：
```java
void backtrack(List<Integer> path, List<Integer> choices){
    // if 满足结束条件 ,假设做10次选择后结束
    if (path.size() == 10){
        pathList.add(path);
        return;
    }

    // for 选择 in 选择列表
    for (Integer choice : choices){
        // 做选择
        path.add(choice);
        backtrack(path, choices);
        // 撤销选择
        path.remove(path.size() - 1);
    }
}
```

**写 backtrack 函数时，需要维护⾛过的「路径」和当前可以做的「选择列 表」，当触发「结束条件」时，将「路径」记⼊结果集。**

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列⽂章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和 「base case」，是不是就对应着⾛过的「路径」，当前的「选择列表」和 「结束条件」？

某种程度上说，**动态规划的暴⼒求解阶段就是回溯算法**。只是有的问题具有重叠⼦问题性质，可以⽤ dp table 或者备忘录优化，将递归树⼤幅剪枝，这就变成了动态规划。⽽今天的两个问题，都**没有重叠⼦问题**，也就是回溯算法问题了，复杂度⾮常⾼是不可避免的。

## BFS 算法框架套路详解

**DFS算法就是回溯算法～**

BFS相对DFS的最主要的区别是：**BFS找到的路径⼀定是最短的，但代价就是空间复杂度⽐DFS⼤很多**

### 算法框架

**问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离，BFS 算法问题其实都是在⼲这个事⼉。**

```java
int bfs(Node start, Node target) {
    // 核⼼数据结构
    Queue<Node> q = new LinkedList<>();
    // 避免⾛回头路
    Set<Node> visited = new HashSet<>();

    q.offer(start);
    visited.add(start);
    int step = 0;

    while (!q.isEmpty()) {
        int len = q.size();
        // 将当前队列节点向四周扩散
        for (int i = 0; i < len; i++) {
            Node cur = q.poll();
            /* 划重点：这⾥判断是否到达终点 */
            if (cur == target) {
                return step;
            }
            /* 将 cur 的相邻节点加⼊队列 */
            for (Node next : cur.nexts) {
                /**
                 * 队列 q 就不说了，BFS 的核⼼数据结构； cur.nexts 泛指 cur 相邻的节点;
                 * visited 的主要作⽤是防⽌⾛回头路，⼤部分时候都是必须的，但是像⼀般的⼆叉树结构，
                 * 没有⼦节点到⽗节点的指针，不会⾛回头路就不需要 visited 。
                 */
                if (!visited.contains(next)) {
                    q.offer(next);
                    visited.add(next);
                }
            }
        }
        /* 划重点：更新步数在这⾥ */
        step++;
    }
    return step;
}
```

eg:

[二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

[解开密码锁的最少次数](https://leetcode.cn/problems/open-the-lock/) : **这个题还是需要仔细品味下的，如果没见过很难想到**

#### 1、为什么 BFS 可以找到最短距离，DFS 不⾏吗？
BFS 的逻辑， depth 每增加⼀次，队列中的所有节点都向前迈⼀步，这保证了第⼀次到达终点的时候，⾛的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对⾼很多。 DFS实际上是靠递归的堆栈记录⾛过的路径，要找到最短路径，肯定得把⼆叉树中所有树杈都探索完才能对⽐出最短的路径有多⻓，⽽ BFS 借助队列做到⼀次⼀步「⻬头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

#### 2、既然 BFS 那么好，为啥 DFS 还要存在？
BFS 可以找到最短距离，但是空间复杂度⾼，⽽ DFS 的空间复杂度较低。 
拿求二叉树的最小深度的例⼦，假设这个⼆叉树是满⼆叉树，节点数为 N ，对于 DFS 算法来说，空间复杂度⽆⾮就是递归堆栈，最坏情况下顶多就是树的⾼度，也就是 O(logN) 。
BFS算法，队列中每次都会储存着⼆叉树⼀层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2 ，⽤ Big O 表⽰的话也就是 O(N) 。

由此观之，BFS 还是有代价的，**⼀般来说在找最短路径的时候使⽤BFS， 其他时候还是 DFS 使⽤得多⼀些（主要是递归代码好写）。**

### 双向 BFS 优化

BFS 算法还有⼀种稍微⾼级⼀点的优化思路：双向BFS，可以进⼀步提⾼算法的效率。**传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停⽌；⽽双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停⽌。** 时间复杂度未变，优化了常数时间。

## 二分查找详解

⼆分查找并不简单，Knuth ⼤佬（发明 KMP 算法的那位）都说⼆分查找：**思路很简单，细节是魔⿁**。

很多⼈喜欢拿整型溢出的 bug 说事⼉，但是⼆分查找真正的坑根本就不是那个细节问题，⽽是在于**到底要给 mid 加⼀还是 减⼀，while ⾥到底⽤ <= 还是 <**。

![二分查找](../../resources/files/binarySearch.png "二分查找labuladong口诀")

本⽂就来探究⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。

### ⼆分查找框架

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right){
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

**分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。**

1.寻找⼀个数（基本的⼆分搜索）

2.寻找左侧边界的⼆分搜索

3.寻找右侧边界的⼆分查找

## 滑动窗口算法框架

### 先导：双指针算法：快慢指针，左右指针

#### 一、快慢指针的常见算法（主要解决链表中的问题）

1.判定链表中是否含有环

![判断链表是否有环](../../resources/files/linkListHasCircle.png "判断链表是否有环")

2.已知链表中含有环，返回这个环的起始位置

![环起点位置](../../resources/files/detectCircle.png "环起点位置")

![环起点位置算法](../../resources/files/detectCircle2.png "环起点位置算法")

3.寻找链表的中点(下面算法当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右)

![链表中点算法](../../resources/files/linkListMid.png "链表中点算法")

寻找链表中点的一个重要作用是对链表进行归并排序。回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。

4.寻找链表的倒数第 k 个元素

快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）

![倒数第k个元素算法](../../resources/files/lastIndexK.png "倒数第k个元素算法")


#### 二、左右指针的常用算法（主要解决数组或字符串的问题，如二分查找）

1.二分查找

2.两数之和

![两数之和](../../resources/files/twoSum.png "两数之和")

3.反转数组

![反转数组](../../resources/files/reverseArray.png "反转数组")

4.滑动窗口算法（主要解决字符串/数组等）

![滑动窗口算法口诀](../../resources/files/slidingWindow.png "滑动窗口labuladong口诀")

### 滑动窗口算法例题

#### LeetCode 0076 最小覆盖子串

滑动窗口算法的思路：

1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。

2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。

3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到right到达字符串S的尽头。

needs和window相当于计数器，分别记录T中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：

![初始状态](../../resources/files/slidingWindowExample01.png "LeetCode0076图解1")

增加right，直到窗口[left, right)包含了T中所有字符：

![增加right](../../resources/files/slidingWindowExample02.png "LeetCode0076图解2")

现在开始增加left，缩小窗口[left, right):

![增加left](../../resources/files/slidingWindowExample03.png "LeetCode0076图解3")

直到窗口中的字符串不再符合要求，left不再继续移动:

![不包含全部T中字符](../../resources/files/slidingWindowExample04.png "LeetCode0076图解4")

之后重复上述过程，先移动right，再移动left…… 直到right指针到达字符串S的末端，算法结束。

#### LeetCode 0567 字符串排列
两个条件：窗口大小等于字符串长度且每个字符出现次数相同

#### LeetCode 0438 找所有字母异位词

#### LeetCode 0003 最长无重复子串
简单题，连need和valid都不需要，更新窗口内数据也只需要简单的更新计数器window即可。 当window[c]值大于 1 时，说明窗口中存在重复字符，不符合条件，移动left缩小窗口。在收缩窗口完成后更新res，因为窗口收缩的 while 条件是存在重复元素，收缩完成后一定保证窗口中没有重复，保存最大的res即可。

## 团灭 LeetCode 股票买卖问题

LeetCode: 121,122,123,188,309,714

⽤状态机的技巧来解决，不要觉得这个名词⾼⼤上，⽂学词汇⽽已，实际上就是 DP table

### 一、穷举框架
对于LeetCode188，我们具体到每⼀天，看看总共有⼏种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的⽬的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就⾏，下⾯实操⼀下就很容易明⽩了。

![股票问题-状态-选择](../../resources/files/stock1.png "状态-选择")

**每天有三种「选择」**：买⼊、卖出、⽆操作，我们⽤ buy, sell, rest 表⽰这三种选择。sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，⼀种是 buy 之后的 rest（持有了股票），⼀种是 sell 之 后的 rest（没有持有股票）

**每天有三个「状态」**，第⼀个是天数，第⼆个是允许交易的最⼤次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨⽤ 1 表⽰持有，0 表⽰没有持有），下面是全部的状态：

![股票问题-状态的全部组合](../../resources/files/stock2.png "状态的全部组合")

想求的最终答案是dp[n - 1][K][0]


### 二、状态转移框架

完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。

![股票问题-今天我没有持有股票的可能](../../resources/files/stock3.png "今天我没有持有股票的可能")

1、我昨天就没有持有，且截至昨天最大交易次数限制为k；然后我今天选择rest，所以我今天还是没有持有，最大交易次数限制依然为k。

2、我昨天持有股票，且截至昨天最大交易次数限制为k；但是今天我sell了，所以我今天没有持有股票了，最大交易次数限制依然为k。

![股票问题-今天我持有股票的可能](../../resources/files/stock4.png "今天我持有股票的可能")

1、我昨天就持有着股票，且截至昨天最大交易次数限制为k；然后今天选择rest，所以我今天还持有着股票，最大交易次数限制依然为k。

2、我昨天本没有持有，且截至昨天最大交易次数限制为k - 1；但今天我选择buy，所以今天我就持有股票了，最大交易次数限制为k。

base case分析

![股票问题-base-case分析](../../resources/files/stock5.png "base-case分析")

总结下：

![股票问题-base-case](../../resources/files/stock6.png "base-case")

### 三、秒杀题目

k = 1 时；

![股票问题-k = 1](../../resources/files/stock7.png "k = 1")

显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进⾏处理。可以这样处理：

```java
for (int i = 0; i < n; i++){
    if (i - 1 == -1) {
        dp[i][0] = 0;
        dp[i][1] = -prices[i];
        continue;
    }
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
}
return dp[n - 1][0];
```

不限制交易次数时（可用于有冷冻时间，手续费等），低空间复杂度解题模板：

```java
public static int maxProfit(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0;
    int dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++){
        int tmp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, tmp - prices[i]);
    }

    return dp_i_0;
}
```

## 团灭 LeetCode 打家劫舍问题

LeetCode: 198, 213, 337

这类题目动态规划的特征很明显，解决动态规划问题就是找「状态」和「选择」，仅此而已。

从左到右走过这一排房子，在每间房子前都有两种选择：抢或者不抢。

如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从下下间房子开始做选择。

如果你不抢这间房子，那么你可以走到下一间房子前，继续做选择。

当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（base case）。



